// src/tools/patterns.ts
// Pattern extractor for the ASCII Dungeon engine MCP server
// Generated by Gemini 3 Flash
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const IGNORE_DIRS = ['node_modules', 'dist', '.git', 'build', 'target'];
export const DEFAULT_BASE_PATH = path.resolve(__dirname, '../../../editor/src');
async function walk(dir) {
    const files = [];
    try {
        const list = await fs.promises.readdir(dir, { withFileTypes: true });
        for (const entry of list) {
            const res = path.resolve(dir, entry.name);
            if (entry.isDirectory()) {
                if (!IGNORE_DIRS.includes(entry.name)) {
                    files.push(...(await walk(res)));
                }
            }
            else if (res.endsWith('.ts') || res.endsWith('.tsx')) {
                files.push(res);
            }
        }
    }
    catch (e) {
        // Ignore errors for unreadable directories
    }
    return files;
}
function getPatternType(names) {
    const counts = {
        PascalCase: 0,
        camelCase: 0,
        'kebab-case': 0,
        snake_case: 0,
        UPPER_SNAKE: 0
    };
    for (const name of names) {
        const cleanName = name.split('.')[0];
        if (/^[A-Z][a-zA-Z0-9]+$/.test(cleanName))
            counts.PascalCase++;
        else if (/^[a-z][a-zA-Z0-9]+$/.test(cleanName))
            counts.camelCase++;
        else if (/^[a-z0-9]+(-[a-z0-9]+)+$/.test(cleanName))
            counts['kebab-case']++;
        else if (/^[a-z0-9]+(_[a-z0-9]+)+$/.test(cleanName))
            counts.snake_case++;
        else if (/^[A-Z0-9]+(_[A-Z0-9]+)+$/.test(cleanName))
            counts.UPPER_SNAKE++;
    }
    return Object.entries(counts)
        .filter(([_, count]) => count > 0)
        .sort((a, b) => b[1] - a[1])
        .map(([type]) => type);
}
export async function extractNamingConventions(basePath = DEFAULT_BASE_PATH) {
    const files = await walk(basePath);
    const fileNames = files.map(f => path.basename(f));
    const classNames = new Set();
    const funcNames = new Set();
    const varNames = new Set();
    for (const file of files) {
        const content = await fs.promises.readFile(file, 'utf-8');
        const classes = content.matchAll(/class\s+([A-Z]\w+)/g);
        for (const m of classes)
            classNames.add(m[1]);
        const funcs = content.matchAll(/(?:function\s+([a-z]\w+)|const\s+([a-z]\w+)\s*=\s*(?:\([^)]*\)|[\w\d]+)\s*=>)/g);
        for (const m of funcs) {
            if (m[1])
                funcNames.add(m[1]);
            if (m[2])
                funcNames.add(m[2]);
        }
        const vars = content.matchAll(/(?:const|let|var)\s+([a-zA-Z_]\w+)/g);
        for (const m of vars) {
            if (!['function', 'class', 'import', 'export', 'return'].includes(m[1])) {
                varNames.add(m[1]);
            }
        }
    }
    return {
        filePatterns: getPatternType(fileNames),
        classPatterns: getPatternType(classNames),
        functionPatterns: getPatternType(funcNames),
        variablePatterns: getPatternType(varNames),
    };
}
export async function extractDecoratorPatterns(basePath = DEFAULT_BASE_PATH) {
    const files = await walk(basePath);
    const decorators = {};
    for (const file of files) {
        const content = await fs.promises.readFile(file, 'utf-8');
        const matches = content.matchAll(/@(\w+)(?:\(([^)]*)\))?/g);
        for (const match of matches) {
            const name = match[1];
            const args = (match[2] || '').trim();
            if (!decorators[name]) {
                const lines = content.split('\n');
                const matchIndex = content.indexOf(match[0]);
                const lineIndex = content.substring(0, matchIndex).split('\n').length - 1;
                const example = lines.slice(lineIndex, lineIndex + 3).join('\n').trim();
                decorators[name] = {
                    count: 0,
                    example,
                    usage: args ? `Configurable decorator: @${name}({ ... })` : `Marker decorator: @${name}`
                };
            }
            decorators[name].count++;
        }
    }
    return Object.entries(decorators)
        .sort((a, b) => b[1].count - a[1].count)
        .map(([name, data]) => ({
        name,
        ...data
    }));
}
export async function extractFileOrganization(basePath = DEFAULT_BASE_PATH) {
    const entries = await fs.promises.readdir(basePath, { withFileTypes: true });
    const directories = [];
    const allImports = new Map();
    const indexExports = [];
    const purposes = {
        components: 'UI elements and visual building blocks',
        engine: 'Core framework and systems integration',
        hooks: 'Reactive state logic and life-cycle hooks',
        lib: 'Shared utilities and business logic',
        renderer: 'Graphics pipeline and viewport management',
        scripting: 'Entity behaviors and component definitions',
        stores: 'Global state and synchronization',
        types: 'Data contracts and interface definitions',
        styles: 'Theme and layout configurations'
    };
    for (const entry of entries) {
        if (entry.isDirectory() && !IGNORE_DIRS.includes(entry.name)) {
            const dirPath = path.join(basePath, entry.name);
            const files = await walk(dirPath);
            const patterns = new Set();
            if (files.some(f => f.includes('.test.')))
                patterns.add('Unit Testing');
            if (files.some(f => f.endsWith('index.ts')))
                patterns.add('Barrel Exports');
            if (files.some(f => f.endsWith('.tsx')))
                patterns.add('React View Layer');
            if (files.some(f => f.includes('.styles.')))
                patterns.add('Scoped CSS');
            directories.push({
                name: entry.name,
                purpose: purposes[entry.name.toLowerCase()] || 'Specialized module',
                fileCount: files.length,
                patterns: Array.from(patterns)
            });
        }
    }
    const allFiles = await walk(basePath);
    for (const file of allFiles) {
        const content = await fs.promises.readFile(file, 'utf-8');
        const imports = content.matchAll(/import\s+.*from\s+['"]([^'"]+)['"]/g);
        for (const m of imports) {
            const source = m[1];
            allImports.set(source, (allImports.get(source) || 0) + 1);
        }
        if (file.endsWith('index.ts')) {
            const exports = content.matchAll(/export\s+.*from\s+['"]([^'"]+)['"]/g);
            for (const m of exports) {
                indexExports.push(`${path.basename(path.dirname(file))}/${m[1]}`);
            }
        }
    }
    const commonImports = Array.from(allImports.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 15)
        .map(([source, count]) => `${source} (${count})`);
    return {
        directories,
        commonImports,
        indexExports: indexExports.slice(0, 30)
    };
}
export async function extractCodePatterns(basePath = DEFAULT_BASE_PATH) {
    const files = await walk(basePath);
    const patterns = [
        {
            name: 'Component Class',
            description: 'Decorated engine component with lifecycle methods',
            example: '@component({ ... })\nexport class XComponent extends Component {\n  @property(...) prop;\n  @action method() {}\n}',
            occurrences: 0
        },
        {
            name: 'Functional UI Component',
            description: 'React component using functional pattern and hooks',
            example: 'export function Widget(props: Props) {\n  const theme = useTheme();\n  return <div />;\n}',
            occurrences: 0
        },
        {
            name: 'Section Dividers',
            description: 'Heavy comment dividers for code organization',
            example: '// ─────────────────────────────────────────────────────────────────────────\n// Section Name\n// ─────────────────────────────────────────────────────────────────────────',
            occurrences: 0
        },
        {
            name: 'Zustand Store',
            description: 'State store using Zustand pattern',
            example: 'export const useStore = create<State>((set, get) => ({\n  value: initial,\n  setValue: (v) => set({ value: v })\n}))',
            occurrences: 0
        },
        {
            name: 'Signal Pattern',
            description: 'Event emitter pattern for component signals',
            example: '@signal({ displayName: "On Event" })\nonEvent: ((data: T) => void) | null = null',
            occurrences: 0
        },
        {
            name: 'Lifecycle Decorator',
            description: 'Lifecycle hook methods using @lifecycle decorator',
            example: '@lifecycle("Execute:Init")\nonInit(): void { }',
            occurrences: 0
        }
    ];
    for (const file of files) {
        const content = await fs.promises.readFile(file, 'utf-8');
        // Component classes
        if (/@component\(/.test(content) && /extends Component/.test(content)) {
            patterns[0].occurrences++;
        }
        // Functional components
        if (/export function \w+\([^)]*\)[^{]*\{[^}]*return\s*\(?\s*</.test(content)) {
            patterns[1].occurrences++;
        }
        // Section dividers
        const dividerMatches = content.match(/\/\/ ─{20,}/g);
        if (dividerMatches) {
            patterns[2].occurrences += dividerMatches.length;
        }
        // Zustand stores
        if (/create<\w+>\(\(set/.test(content)) {
            patterns[3].occurrences++;
        }
        // Signals
        const signalMatches = content.match(/@signal\(/g);
        if (signalMatches) {
            patterns[4].occurrences += signalMatches.length;
        }
        // Lifecycle
        const lifecycleMatches = content.match(/@lifecycle\(/g);
        if (lifecycleMatches) {
            patterns[5].occurrences += lifecycleMatches.length;
        }
    }
    return patterns.filter(p => p.occurrences > 0);
}
export async function getPatternSummary(basePath = DEFAULT_BASE_PATH) {
    const [naming, decorators, organization, codePatterns] = await Promise.all([
        extractNamingConventions(basePath),
        extractDecoratorPatterns(basePath),
        extractFileOrganization(basePath),
        extractCodePatterns(basePath)
    ]);
    return {
        naming,
        decorators,
        organization,
        codePatterns
    };
}
