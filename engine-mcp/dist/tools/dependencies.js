// src/tools/dependencies.ts
// Dependency graph analyzer for the ASCII Dungeon engine MCP server
// Generated by Gemini 3 Flash
import * as fs from 'fs';
import * as path from 'path';
import * as ts from 'typescript';
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
export const DEFAULT_BASE_PATH = path.resolve(__dirname, '../../../editor/src');
async function getAllFiles(dirPath, arrayOfFiles = []) {
    const files = fs.readdirSync(dirPath);
    for (const file of files) {
        if (file === 'node_modules' || file === 'dist' || file === '.git')
            continue;
        const filePath = path.join(dirPath, file);
        const stat = fs.statSync(filePath);
        if (stat.isDirectory()) {
            await getAllFiles(filePath, arrayOfFiles);
        }
        else if (filePath.endsWith('.ts') || filePath.endsWith('.tsx')) {
            arrayOfFiles.push(filePath);
        }
    }
    return arrayOfFiles;
}
function resolveImportPath(sourceFile, importPath) {
    if (!importPath.startsWith('.'))
        return null;
    const directory = path.dirname(sourceFile);
    const resolvedPath = path.resolve(directory, importPath);
    const extensions = ['.ts', '.tsx', '.d.ts', '.js', '.jsx'];
    if (fs.existsSync(resolvedPath) && fs.statSync(resolvedPath).isFile()) {
        return resolvedPath;
    }
    for (const ext of extensions) {
        const fullPath = resolvedPath + ext;
        if (fs.existsSync(fullPath)) {
            return fullPath;
        }
    }
    const indexFiles = ['/index.ts', '/index.tsx', '/index.d.ts', '/index.js', '/index.jsx'];
    for (const indexFile of indexFiles) {
        const fullPath = resolvedPath + indexFile;
        if (fs.existsSync(fullPath)) {
            return fullPath;
        }
    }
    return null;
}
function getImports(filePath) {
    try {
        const content = fs.readFileSync(filePath, 'utf8');
        const sourceFile = ts.createSourceFile(filePath, content, ts.ScriptTarget.Latest, true);
        const imports = [];
        function visit(node) {
            if (ts.isImportDeclaration(node)) {
                if (node.moduleSpecifier && ts.isStringLiteral(node.moduleSpecifier)) {
                    const resolved = resolveImportPath(filePath, node.moduleSpecifier.text);
                    if (resolved)
                        imports.push(resolved);
                }
            }
            else if (ts.isExportDeclaration(node)) {
                if (node.moduleSpecifier && ts.isStringLiteral(node.moduleSpecifier)) {
                    const resolved = resolveImportPath(filePath, node.moduleSpecifier.text);
                    if (resolved)
                        imports.push(resolved);
                }
            }
            else if (ts.isCallExpression(node)) {
                if (node.expression.kind === ts.SyntaxKind.ImportKeyword && node.arguments.length > 0) {
                    const arg = node.arguments[0];
                    if (ts.isStringLiteral(arg)) {
                        const resolved = resolveImportPath(filePath, arg.text);
                        if (resolved)
                            imports.push(resolved);
                    }
                }
            }
            ts.forEachChild(node, visit);
        }
        visit(sourceFile);
        return Array.from(new Set(imports));
    }
    catch (e) {
        return [];
    }
}
export async function buildDependencyGraph(basePath = DEFAULT_BASE_PATH) {
    const files = await getAllFiles(basePath);
    const graph = {
        nodes: new Map(),
        edges: new Map()
    };
    for (const file of files) {
        graph.nodes.set(file, {
            filePath: file,
            imports: [],
            importedBy: []
        });
        graph.edges.set(file, new Set());
    }
    for (const file of files) {
        const node = graph.nodes.get(file);
        const imports = getImports(file);
        for (const imp of imports) {
            if (graph.nodes.has(imp)) {
                node.imports.push(imp);
                graph.edges.get(file).add(imp);
                graph.nodes.get(imp).importedBy.push(file);
            }
        }
    }
    return graph;
}
export function getFileDependencies(filePath, graph) {
    return graph.nodes.get(filePath)?.imports || [];
}
export function getFileDependents(filePath, graph) {
    return graph.nodes.get(filePath)?.importedBy || [];
}
export function findCircularDependencies(graph) {
    const circulars = [];
    const visited = new Set();
    const recStack = new Set();
    function detectCycle(node, currentPath) {
        visited.add(node);
        recStack.add(node);
        currentPath.push(node);
        const neighbors = graph.edges.get(node);
        if (neighbors) {
            for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    detectCycle(neighbor, [...currentPath]);
                }
                else if (recStack.has(neighbor)) {
                    const cycleStart = currentPath.indexOf(neighbor);
                    circulars.push(currentPath.slice(cycleStart));
                }
            }
        }
        recStack.delete(node);
    }
    for (const node of graph.nodes.keys()) {
        if (!visited.has(node)) {
            detectCycle(node, []);
        }
    }
    return circulars;
}
export function findEntryPoints(graph) {
    const entries = [];
    for (const [filePath, node] of graph.nodes) {
        if (node.importedBy.length === 0) {
            entries.push(filePath);
        }
    }
    return entries;
}
export function findCoreModules(graph, threshold = 5) {
    return Array.from(graph.nodes.values())
        .filter(node => node.importedBy.length >= threshold)
        .sort((a, b) => b.importedBy.length - a.importedBy.length)
        .map(node => node.filePath);
}
export function getDependencyTree(filePath, graph, maxDepth = 10, currentDepth = 0, visited = new Set()) {
    const treeNode = {
        file: filePath,
        dependencies: []
    };
    if (currentDepth >= maxDepth || visited.has(filePath)) {
        return treeNode;
    }
    visited.add(filePath);
    const deps = getFileDependencies(filePath, graph);
    for (const dep of deps) {
        treeNode.dependencies.push(getDependencyTree(dep, graph, maxDepth, currentDepth + 1, new Set(visited)));
    }
    return treeNode;
}
/**
 * Get a summary of the dependency graph
 */
export function getDependencyStats(graph) {
    let totalEdges = 0;
    let totalImports = 0;
    let totalImportedBy = 0;
    for (const node of graph.nodes.values()) {
        totalImports += node.imports.length;
        totalImportedBy += node.importedBy.length;
        totalEdges += node.imports.length;
    }
    const totalFiles = graph.nodes.size;
    const circulars = findCircularDependencies(graph);
    const entries = findEntryPoints(graph);
    const core = findCoreModules(graph);
    return {
        totalFiles,
        totalEdges,
        avgImports: totalFiles > 0 ? totalImports / totalFiles : 0,
        avgImportedBy: totalFiles > 0 ? totalImportedBy / totalFiles : 0,
        circularCount: circulars.length,
        entryPoints: entries.length,
        coreModules: core.length
    };
}
