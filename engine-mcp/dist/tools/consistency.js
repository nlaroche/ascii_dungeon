// src/tools/consistency.ts
// Consistency checker for the ASCII Dungeon engine MCP server
// Generated by Gemini 3 Flash
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
export const DEFAULT_BASE_PATH = path.resolve(__dirname, '../../../editor/src');
/**
 * Helper to recursively walk a directory
 */
async function walk(dir) {
    const files = await fs.promises.readdir(dir, { withFileTypes: true });
    const paths = await Promise.all(files.map(async (file) => {
        if (file.name === 'node_modules' || file.name === 'dist' || file.name === '.git') {
            return [];
        }
        const res = path.resolve(dir, file.name);
        return file.isDirectory() ? walk(res) : res;
    }));
    return paths.flat();
}
/**
 * Check if a file is a TypeScript file and not a test/index file
 */
function isSourceFile(filePath) {
    return (filePath.endsWith('.ts') || filePath.endsWith('.tsx')) &&
        !filePath.endsWith('.test.ts') &&
        !filePath.endsWith('.test.tsx') &&
        !path.basename(filePath).startsWith('index.');
}
export async function checkComponentConsistency(basePath = DEFAULT_BASE_PATH) {
    const issues = [];
    const componentsDir = path.join(basePath, 'scripting/components');
    if (!fs.existsSync(componentsDir))
        return issues;
    const files = await walk(componentsDir);
    for (const file of files) {
        if (!isSourceFile(file))
            continue;
        const fileName = path.basename(file);
        const relativePath = path.relative(basePath, file);
        // Rule 1: Component files should end with Component.ts
        if (!fileName.endsWith('Component.ts')) {
            issues.push({
                file: relativePath,
                severity: 'warning',
                rule: 'component-filename-suffix',
                message: 'Component files should end with "Component.ts"',
                suggestion: `Rename ${fileName} to ${fileName.replace('.ts', 'Component.ts')}`
            });
        }
        const content = await fs.promises.readFile(file, 'utf-8');
        // Rule 2: Components should have @component decorator
        if (!content.includes('@component(')) {
            issues.push({
                file: relativePath,
                severity: 'error',
                rule: 'missing-component-decorator',
                message: 'Classes in scripting/components must have the @component decorator'
            });
        }
    }
    return issues;
}
export async function checkNamingConsistency(basePath = DEFAULT_BASE_PATH) {
    const issues = [];
    const files = await walk(basePath);
    for (const file of files) {
        if (!isSourceFile(file))
            continue;
        const content = await fs.promises.readFile(file, 'utf-8');
        const relativePath = path.relative(basePath, file);
        const lines = content.split('\n');
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            // Rule 5: Classes should be PascalCase
            const classMatch = line.match(/class\s+(\w+)/);
            if (classMatch) {
                const className = classMatch[1];
                if (!/^[A-Z][a-zA-Z0-9]+$/.test(className)) {
                    issues.push({
                        file: relativePath,
                        line: i + 1,
                        severity: 'warning',
                        rule: 'naming-class-pascal',
                        message: `Class name "${className}" should be PascalCase`,
                        suggestion: `Rename to ${className.charAt(0).toUpperCase()}${className.slice(1)}`
                    });
                }
            }
            // Rule 6: Functions should be camelCase
            const funcMatch = line.match(/(?:function|const|let)\s+([a-z]\w*)\s*=\s*(?:\([^)]*\)|function)/) ||
                line.match(/function\s+([a-zA-Z]\w*)\s*\(/);
            if (funcMatch) {
                const funcName = funcMatch[1];
                // Skip if it looks like a React component (PascalCase) in a .tsx file
                const isReactComponent = file.endsWith('.tsx') && /^[A-Z]/.test(funcName);
                if (!isReactComponent && !/^[a-z][a-zA-Z0-9]*$/.test(funcName)) {
                    // Basic check, avoid common false positives like Uppercase exports that are actually constants
                    if (/^[A-Z_]+$/.test(funcName))
                        continue;
                    issues.push({
                        file: relativePath,
                        line: i + 1,
                        severity: 'info',
                        rule: 'naming-function-camel',
                        message: `Function name "${funcName}" should be camelCase`,
                    });
                }
            }
        }
    }
    return issues;
}
export async function checkImportConsistency(basePath = DEFAULT_BASE_PATH) {
    const issues = [];
    const allFiles = await walk(basePath);
    const sourceFiles = allFiles.filter(isSourceFile);
    // For Rule 7: All exports should be used somewhere
    const exportMap = new Map();
    for (const file of sourceFiles) {
        const content = await fs.promises.readFile(file, 'utf-8');
        const relativePath = path.relative(basePath, file);
        const lines = content.split('\n');
        let lastImportType = null;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            // Rule 8: Imports should be organized (external first, then internal)
            if (line.startsWith('import ')) {
                const sourceMatch = line.match(/from\s+['"]([^'"]+)['"]/);
                if (sourceMatch) {
                    const source = sourceMatch[1];
                    const isInternal = source.startsWith('.') || source.startsWith('@/');
                    const currentType = isInternal ? 'internal' : 'external';
                    if (lastImportType === 'internal' && currentType === 'external') {
                        issues.push({
                            file: relativePath,
                            line: i + 1,
                            severity: 'info',
                            rule: 'import-organization',
                            message: 'External imports should come before internal imports',
                            suggestion: 'Move this import above internal imports'
                        });
                    }
                    lastImportType = currentType;
                }
            }
            else if (line.length > 0 && !line.startsWith('//') && !line.startsWith('/*')) {
                lastImportType = null; // Reset when we leave the import section
            }
            // Collect exports for Rule 7
            const exportMatch = line.match(/^export\s+(?:class|function|const|enum|type|interface)\s+([a-zA-Z]\w*)/);
            if (exportMatch) {
                const name = exportMatch[1];
                exportMap.set(name, { file: relativePath, line: i + 1, count: 0 });
            }
        }
        // Check usage of other exports in this file (simple string search)
        for (const [name, data] of exportMap.entries()) {
            if (data.file !== relativePath && content.includes(name)) {
                data.count++;
            }
        }
    }
    // Rule 7 report - only report truly unused exports (skip common things like types)
    for (const [name, data] of exportMap.entries()) {
        if (data.count === 0 && !name.endsWith('Props') && !name.endsWith('State')) {
            issues.push({
                file: data.file,
                line: data.line,
                severity: 'info',
                rule: 'unused-export',
                message: `Export "${name}" seems to be unused in the project`,
            });
        }
    }
    return issues;
}
export async function checkDecoratorConsistency(basePath = DEFAULT_BASE_PATH) {
    const issues = [];
    const files = await walk(basePath);
    for (const file of files) {
        if (!isSourceFile(file))
            continue;
        const content = await fs.promises.readFile(file, 'utf-8');
        const relativePath = path.relative(basePath, file);
        const lines = content.split('\n');
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            // Rule 3: Properties should have @property decorator with type
            const propertyMatch = line.match(/@property\s*\(\s*\{([^}]*)\}\s*\)/);
            if (propertyMatch) {
                const opts = propertyMatch[1];
                if (!opts.includes('type:')) {
                    issues.push({
                        file: relativePath,
                        line: i + 1,
                        severity: 'error',
                        rule: 'property-decorator-missing-type',
                        message: '@property decorator is missing the "type" field',
                        suggestion: 'Add type: "string" | "number" | "boolean" etc.'
                    });
                }
            }
            // Rule 4: Actions should have @action decorator
            // Check if methods in components that look like actions are missing it
            if (relativePath.includes('scripting/components') && line.includes('():') && !line.includes('private')) {
                const prevLine = i > 0 ? lines[i - 1] : '';
                const prevPrevLine = i > 1 ? lines[i - 2] : '';
                if (!prevLine.includes('@action') && !prevPrevLine.includes('@action') &&
                    !line.includes('constructor') && !line.includes('onInit') &&
                    !line.includes('onUpdate') && !line.includes('onDispose') &&
                    !line.includes('private') && !line.includes('protected')) {
                    issues.push({
                        file: relativePath,
                        line: i + 1,
                        severity: 'warning',
                        rule: 'missing-action-decorator',
                        message: 'Public component method might be missing @action decorator'
                    });
                }
            }
        }
    }
    return issues;
}
export async function runAllChecks(basePath = DEFAULT_BASE_PATH) {
    const allIssues = (await Promise.all([
        checkComponentConsistency(basePath),
        checkNamingConsistency(basePath),
        checkImportConsistency(basePath),
        checkDecoratorConsistency(basePath)
    ])).flat();
    const summary = {
        errors: allIssues.filter(i => i.severity === 'error').length,
        warnings: allIssues.filter(i => i.severity === 'warning').length,
        info: allIssues.filter(i => i.severity === 'info').length
    };
    return {
        issues: allIssues,
        summary,
        passed: summary.errors === 0
    };
}
/**
 * Get a formatted report string
 */
export function formatReport(report) {
    const lines = [];
    lines.push('='.repeat(60));
    lines.push('Consistency Check Report');
    lines.push('='.repeat(60));
    lines.push('');
    if (report.issues.length === 0) {
        lines.push('No issues found.');
    }
    else {
        // Group by file
        const byFile = new Map();
        for (const issue of report.issues) {
            const existing = byFile.get(issue.file) || [];
            existing.push(issue);
            byFile.set(issue.file, existing);
        }
        for (const [file, issues] of byFile) {
            lines.push(`${file}:`);
            for (const issue of issues) {
                const loc = issue.line ? `:${issue.line}` : '';
                const sev = issue.severity.toUpperCase().padEnd(7);
                lines.push(`  ${loc.padEnd(5)} [${sev}] ${issue.message}`);
                if (issue.suggestion) {
                    lines.push(`         â†’ ${issue.suggestion}`);
                }
            }
            lines.push('');
        }
    }
    lines.push('-'.repeat(60));
    lines.push(`Summary: ${report.summary.errors} errors, ${report.summary.warnings} warnings, ${report.summary.info} info`);
    lines.push(`Status: ${report.passed ? 'PASSED' : 'FAILED'}`);
    return lines.join('\n');
}
