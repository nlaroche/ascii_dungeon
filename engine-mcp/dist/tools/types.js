// src/tools/types.ts
// TypeScript type extraction tools - Generated by Gemini 3 Flash
import * as ts from 'typescript';
import * as fs from 'fs';
import * as path from 'path';
function getJSDoc(node) {
    const jsDocNode = node.jsDoc;
    if (jsDocNode && jsDocNode.length > 0) {
        return jsDocNode[0].comment?.toString();
    }
    return undefined;
}
function getSourceFile(filePath) {
    const content = fs.readFileSync(filePath, 'utf8');
    return ts.createSourceFile(filePath, content, ts.ScriptTarget.Latest, true);
}
export function extractInterfaces(filePath) {
    const sourceFile = getSourceFile(filePath);
    const interfaces = [];
    function visit(node) {
        if (ts.isInterfaceDeclaration(node)) {
            const properties = node.members
                .filter(ts.isPropertySignature)
                .map((prop) => ({
                name: prop.name.getText(sourceFile),
                type: prop.type?.getText(sourceFile) ?? 'any',
                isOptional: !!prop.questionToken,
                jsdoc: getJSDoc(prop),
            }));
            const extendsClauses = [];
            if (node.heritageClauses) {
                for (const clause of node.heritageClauses) {
                    if (clause.token === ts.SyntaxKind.ExtendsKeyword) {
                        clause.types.forEach((t) => extendsClauses.push(t.getText(sourceFile)));
                    }
                }
            }
            interfaces.push({
                name: node.name.text,
                properties,
                extends: extendsClauses,
                jsdoc: getJSDoc(node),
            });
        }
        ts.forEachChild(node, visit);
    }
    visit(sourceFile);
    return interfaces;
}
export function extractTypes(filePath) {
    const sourceFile = getSourceFile(filePath);
    const types = [];
    function visit(node) {
        if (ts.isTypeAliasDeclaration(node)) {
            types.push({
                name: node.name.text,
                type: node.type.getText(sourceFile),
                jsdoc: getJSDoc(node),
            });
        }
        ts.forEachChild(node, visit);
    }
    visit(sourceFile);
    return types;
}
export function extractExports(filePath) {
    const sourceFile = getSourceFile(filePath);
    const exports = [];
    function visit(node) {
        const modifiers = ts.canHaveModifiers(node) ? ts.getModifiers(node) : undefined;
        const isExported = modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword);
        if (isExported) {
            if (ts.isVariableStatement(node)) {
                node.declarationList.declarations.forEach((decl) => {
                    exports.push(decl.name.getText(sourceFile));
                });
            }
            else if (ts.isFunctionDeclaration(node) || ts.isClassDeclaration(node) || ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node) || ts.isEnumDeclaration(node)) {
                if (node.name) {
                    exports.push(node.name.text);
                }
            }
        }
        else if (ts.isExportDeclaration(node)) {
            if (node.exportClause && ts.isNamedExports(node.exportClause)) {
                node.exportClause.elements.forEach((spec) => {
                    exports.push(spec.name.text);
                });
            }
        }
        ts.forEachChild(node, visit);
    }
    visit(sourceFile);
    return exports;
}
export function getTypeUsages(typeName, basePath) {
    const usages = [];
    function walkDir(dir) {
        const files = fs.readdirSync(dir);
        for (const file of files) {
            const fullPath = path.join(dir, file);
            if (fs.statSync(fullPath).isDirectory()) {
                if (file !== 'node_modules')
                    walkDir(fullPath);
            }
            else if (fullPath.endsWith('.ts') || fullPath.endsWith('.tsx')) {
                findUsagesInFile(fullPath);
            }
        }
    }
    function findUsagesInFile(filePath) {
        const sourceFile = getSourceFile(filePath);
        function visit(node) {
            if (ts.isIdentifier(node) && node.text === typeName) {
                const parent = node.parent;
                // Avoid counting the definition itself as a usage in some contexts
                const isDefinition = (ts.isInterfaceDeclaration(parent) && parent.name === node) ||
                    (ts.isTypeAliasDeclaration(parent) && parent.name === node) ||
                    (ts.isClassDeclaration(parent) && parent.name === node);
                if (!isDefinition) {
                    const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());
                    usages.push({
                        filePath,
                        line: line + 1,
                        character: character + 1,
                        context: node.parent.getText(sourceFile),
                    });
                }
            }
            ts.forEachChild(node, visit);
        }
        visit(sourceFile);
    }
    walkDir(basePath);
    return usages;
}
