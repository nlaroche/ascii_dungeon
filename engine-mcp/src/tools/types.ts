// src/tools/types.ts
// TypeScript type extraction tools - Generated by Gemini 3 Flash

import * as ts from 'typescript';
import * as fs from 'fs';
import * as path from 'path';

export interface PropertyInfo {
  name: string;
  type: string;
  isOptional: boolean;
  jsdoc?: string;
}

export interface InterfaceInfo {
  name: string;
  properties: PropertyInfo[];
  extends: string[];
  jsdoc?: string;
}

export interface TypeAliasInfo {
  name: string;
  type: string;
  jsdoc?: string;
}

export interface UsageInfo {
  filePath: string;
  line: number;
  character: number;
  context: string;
}

function getJSDoc(node: ts.Node): string | undefined {
  const jsDocNode = (node as any).jsDoc as ts.JSDoc[];
  if (jsDocNode && jsDocNode.length > 0) {
    return jsDocNode[0].comment?.toString();
  }
  return undefined;
}

function getSourceFile(filePath: string): ts.SourceFile {
  const content = fs.readFileSync(filePath, 'utf8');
  return ts.createSourceFile(filePath, content, ts.ScriptTarget.Latest, true);
}

export function extractInterfaces(filePath: string): InterfaceInfo[] {
  const sourceFile = getSourceFile(filePath);
  const interfaces: InterfaceInfo[] = [];

  function visit(node: ts.Node) {
    if (ts.isInterfaceDeclaration(node)) {
      const properties: PropertyInfo[] = node.members
        .filter(ts.isPropertySignature)
        .map((prop) => ({
          name: prop.name.getText(sourceFile),
          type: prop.type?.getText(sourceFile) ?? 'any',
          isOptional: !!prop.questionToken,
          jsdoc: getJSDoc(prop),
        }));

      const extendsClauses: string[] = [];
      if (node.heritageClauses) {
        for (const clause of node.heritageClauses) {
          if (clause.token === ts.SyntaxKind.ExtendsKeyword) {
            clause.types.forEach((t) => extendsClauses.push(t.getText(sourceFile)));
          }
        }
      }

      interfaces.push({
        name: node.name.text,
        properties,
        extends: extendsClauses,
        jsdoc: getJSDoc(node),
      });
    }
    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
  return interfaces;
}

export function extractTypes(filePath: string): TypeAliasInfo[] {
  const sourceFile = getSourceFile(filePath);
  const types: TypeAliasInfo[] = [];

  function visit(node: ts.Node) {
    if (ts.isTypeAliasDeclaration(node)) {
      types.push({
        name: node.name.text,
        type: node.type.getText(sourceFile),
        jsdoc: getJSDoc(node),
      });
    }
    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
  return types;
}

export function extractExports(filePath: string): string[] {
  const sourceFile = getSourceFile(filePath);
  const exports: string[] = [];

  function visit(node: ts.Node) {
    const modifiers = ts.canHaveModifiers(node) ? ts.getModifiers(node) : undefined;
    const isExported = modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword);

    if (isExported) {
      if (ts.isVariableStatement(node)) {
        node.declarationList.declarations.forEach((decl) => {
          exports.push(decl.name.getText(sourceFile));
        });
      } else if (ts.isFunctionDeclaration(node) || ts.isClassDeclaration(node) || ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node) || ts.isEnumDeclaration(node)) {
        if (node.name) {
          exports.push(node.name.text);
        }
      }
    } else if (ts.isExportDeclaration(node)) {
      if (node.exportClause && ts.isNamedExports(node.exportClause)) {
        node.exportClause.elements.forEach((spec) => {
          exports.push(spec.name.text);
        });
      }
    }
    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
  return exports;
}

export function getTypeUsages(typeName: string, basePath: string): UsageInfo[] {
  const usages: UsageInfo[] = [];

  function walkDir(dir: string) {
    const files = fs.readdirSync(dir);
    for (const file of files) {
      const fullPath = path.join(dir, file);
      if (fs.statSync(fullPath).isDirectory()) {
        if (file !== 'node_modules') walkDir(fullPath);
      } else if (fullPath.endsWith('.ts') || fullPath.endsWith('.tsx')) {
        findUsagesInFile(fullPath);
      }
    }
  }

  function findUsagesInFile(filePath: string) {
    const sourceFile = getSourceFile(filePath);

    function visit(node: ts.Node) {
      if (ts.isIdentifier(node) && node.text === typeName) {
        const parent = node.parent;
        // Avoid counting the definition itself as a usage in some contexts
        const isDefinition =
          (ts.isInterfaceDeclaration(parent) && parent.name === node) ||
          (ts.isTypeAliasDeclaration(parent) && parent.name === node) ||
          (ts.isClassDeclaration(parent) && parent.name === node);

        if (!isDefinition) {
          const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());
          usages.push({
            filePath,
            line: line + 1,
            character: character + 1,
            context: node.parent.getText(sourceFile),
          });
        }
      }
      ts.forEachChild(node, visit);
    }

    visit(sourceFile);
  }

  walkDir(basePath);
  return usages;
}
