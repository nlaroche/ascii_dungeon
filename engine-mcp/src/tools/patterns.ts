// src/tools/patterns.ts
// Pattern extractor for the ASCII Dungeon engine MCP server
// Generated by Gemini 3 Flash

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export interface NamingConventions {
  filePatterns: string[];
  classPatterns: string[];
  functionPatterns: string[];
  variablePatterns: string[];
}

export interface DecoratorPattern {
  name: string;
  usage: string;
  example: string;
  count: number;
}

export interface DirectoryInfo {
  name: string;
  purpose: string;
  fileCount: number;
  patterns: string[];
}

export interface FileOrganization {
  directories: DirectoryInfo[];
  commonImports: string[];
  indexExports: string[];
}

export interface CodePattern {
  name: string;
  description: string;
  example: string;
  occurrences: number;
}

export interface PatternSummary {
  naming: NamingConventions;
  decorators: DecoratorPattern[];
  organization: FileOrganization;
  codePatterns: CodePattern[];
}

const IGNORE_DIRS = ['node_modules', 'dist', '.git', 'build', 'target'];
export const DEFAULT_BASE_PATH = path.resolve(__dirname, '../../../editor/src');

async function walk(dir: string): Promise<string[]> {
  const files: string[] = [];
  try {
    const list = await fs.promises.readdir(dir, { withFileTypes: true });
    for (const entry of list) {
      const res = path.resolve(dir, entry.name);
      if (entry.isDirectory()) {
        if (!IGNORE_DIRS.includes(entry.name)) {
          files.push(...(await walk(res)));
        }
      } else if (res.endsWith('.ts') || res.endsWith('.tsx')) {
        files.push(res);
      }
    }
  } catch (e) {
    // Ignore errors for unreadable directories
  }
  return files;
}

function getPatternType(names: Iterable<string>): string[] {
  const counts: Record<string, number> = {
    PascalCase: 0,
    camelCase: 0,
    'kebab-case': 0,
    snake_case: 0,
    UPPER_SNAKE: 0
  };

  for (const name of names) {
    const cleanName = name.split('.')[0];
    if (/^[A-Z][a-zA-Z0-9]+$/.test(cleanName)) counts.PascalCase++;
    else if (/^[a-z][a-zA-Z0-9]+$/.test(cleanName)) counts.camelCase++;
    else if (/^[a-z0-9]+(-[a-z0-9]+)+$/.test(cleanName)) counts['kebab-case']++;
    else if (/^[a-z0-9]+(_[a-z0-9]+)+$/.test(cleanName)) counts.snake_case++;
    else if (/^[A-Z0-9]+(_[A-Z0-9]+)+$/.test(cleanName)) counts.UPPER_SNAKE++;
  }

  return Object.entries(counts)
    .filter(([_, count]) => count > 0)
    .sort((a, b) => b[1] - a[1])
    .map(([type]) => type);
}

export async function extractNamingConventions(basePath: string = DEFAULT_BASE_PATH): Promise<NamingConventions> {
  const files = await walk(basePath);
  const fileNames = files.map(f => path.basename(f));

  const classNames = new Set<string>();
  const funcNames = new Set<string>();
  const varNames = new Set<string>();

  for (const file of files) {
    const content = await fs.promises.readFile(file, 'utf-8');

    const classes = content.matchAll(/class\s+([A-Z]\w+)/g);
    for (const m of classes) classNames.add(m[1]);

    const funcs = content.matchAll(/(?:function\s+([a-z]\w+)|const\s+([a-z]\w+)\s*=\s*(?:\([^)]*\)|[\w\d]+)\s*=>)/g);
    for (const m of funcs) {
      if (m[1]) funcNames.add(m[1]);
      if (m[2]) funcNames.add(m[2]);
    }

    const vars = content.matchAll(/(?:const|let|var)\s+([a-zA-Z_]\w+)/g);
    for (const m of vars) {
      if (!['function', 'class', 'import', 'export', 'return'].includes(m[1])) {
        varNames.add(m[1]);
      }
    }
  }

  return {
    filePatterns: getPatternType(fileNames),
    classPatterns: getPatternType(classNames),
    functionPatterns: getPatternType(funcNames),
    variablePatterns: getPatternType(varNames),
  };
}

export async function extractDecoratorPatterns(basePath: string = DEFAULT_BASE_PATH): Promise<DecoratorPattern[]> {
  const files = await walk(basePath);
  const decorators: Record<string, { count: number, example: string, usage: string }> = {};

  for (const file of files) {
    const content = await fs.promises.readFile(file, 'utf-8');
    const matches = content.matchAll(/@(\w+)(?:\(([^)]*)\))?/g);
    for (const match of matches) {
      const name = match[1];
      const args = (match[2] || '').trim();

      if (!decorators[name]) {
        const lines = content.split('\n');
        const matchIndex = content.indexOf(match[0]);
        const lineIndex = content.substring(0, matchIndex).split('\n').length - 1;
        const example = lines.slice(lineIndex, lineIndex + 3).join('\n').trim();

        decorators[name] = {
          count: 0,
          example,
          usage: args ? `Configurable decorator: @${name}({ ... })` : `Marker decorator: @${name}`
        };
      }
      decorators[name].count++;
    }
  }

  return Object.entries(decorators)
    .sort((a, b) => b[1].count - a[1].count)
    .map(([name, data]) => ({
      name,
      ...data
    }));
}

export async function extractFileOrganization(basePath: string = DEFAULT_BASE_PATH): Promise<FileOrganization> {
  const entries = await fs.promises.readdir(basePath, { withFileTypes: true });
  const directories: DirectoryInfo[] = [];
  const allImports = new Map<string, number>();
  const indexExports: string[] = [];

  const purposes: Record<string, string> = {
    components: 'UI elements and visual building blocks',
    engine: 'Core framework and systems integration',
    hooks: 'Reactive state logic and life-cycle hooks',
    lib: 'Shared utilities and business logic',
    renderer: 'Graphics pipeline and viewport management',
    scripting: 'Entity behaviors and component definitions',
    stores: 'Global state and synchronization',
    types: 'Data contracts and interface definitions',
    styles: 'Theme and layout configurations'
  };

  for (const entry of entries) {
    if (entry.isDirectory() && !IGNORE_DIRS.includes(entry.name)) {
      const dirPath = path.join(basePath, entry.name);
      const files = await walk(dirPath);

      const patterns = new Set<string>();
      if (files.some(f => f.includes('.test.'))) patterns.add('Unit Testing');
      if (files.some(f => f.endsWith('index.ts'))) patterns.add('Barrel Exports');
      if (files.some(f => f.endsWith('.tsx'))) patterns.add('React View Layer');
      if (files.some(f => f.includes('.styles.'))) patterns.add('Scoped CSS');

      directories.push({
        name: entry.name,
        purpose: purposes[entry.name.toLowerCase()] || 'Specialized module',
        fileCount: files.length,
        patterns: Array.from(patterns)
      });
    }
  }

  const allFiles = await walk(basePath);
  for (const file of allFiles) {
    const content = await fs.promises.readFile(file, 'utf-8');
    const imports = content.matchAll(/import\s+.*from\s+['"]([^'"]+)['"]/g);
    for (const m of imports) {
      const source = m[1];
      allImports.set(source, (allImports.get(source) || 0) + 1);
    }

    if (file.endsWith('index.ts')) {
      const exports = content.matchAll(/export\s+.*from\s+['"]([^'"]+)['"]/g);
      for (const m of exports) {
        indexExports.push(`${path.basename(path.dirname(file))}/${m[1]}`);
      }
    }
  }

  const commonImports = Array.from(allImports.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 15)
    .map(([source, count]) => `${source} (${count})`);

  return {
    directories,
    commonImports,
    indexExports: indexExports.slice(0, 30)
  };
}

export async function extractCodePatterns(basePath: string = DEFAULT_BASE_PATH): Promise<CodePattern[]> {
  const files = await walk(basePath);
  const patterns: CodePattern[] = [
    {
      name: 'Component Class',
      description: 'Decorated engine component with lifecycle methods',
      example: '@component({ ... })\nexport class XComponent extends Component {\n  @property(...) prop;\n  @action method() {}\n}',
      occurrences: 0
    },
    {
      name: 'Functional UI Component',
      description: 'React component using functional pattern and hooks',
      example: 'export function Widget(props: Props) {\n  const theme = useTheme();\n  return <div />;\n}',
      occurrences: 0
    },
    {
      name: 'Section Dividers',
      description: 'Heavy comment dividers for code organization',
      example: '// ─────────────────────────────────────────────────────────────────────────\n// Section Name\n// ─────────────────────────────────────────────────────────────────────────',
      occurrences: 0
    },
    {
      name: 'Zustand Store',
      description: 'State store using Zustand pattern',
      example: 'export const useStore = create<State>((set, get) => ({\n  value: initial,\n  setValue: (v) => set({ value: v })\n}))',
      occurrences: 0
    },
    {
      name: 'Signal Pattern',
      description: 'Event emitter pattern for component signals',
      example: '@signal({ displayName: "On Event" })\nonEvent: ((data: T) => void) | null = null',
      occurrences: 0
    },
    {
      name: 'Lifecycle Decorator',
      description: 'Lifecycle hook methods using @lifecycle decorator',
      example: '@lifecycle("Execute:Init")\nonInit(): void { }',
      occurrences: 0
    }
  ];

  for (const file of files) {
    const content = await fs.promises.readFile(file, 'utf-8');

    // Component classes
    if (/@component\(/.test(content) && /extends Component/.test(content)) {
      patterns[0].occurrences++;
    }

    // Functional components
    if (/export function \w+\([^)]*\)[^{]*\{[^}]*return\s*\(?\s*</.test(content)) {
      patterns[1].occurrences++;
    }

    // Section dividers
    const dividerMatches = content.match(/\/\/ ─{20,}/g);
    if (dividerMatches) {
      patterns[2].occurrences += dividerMatches.length;
    }

    // Zustand stores
    if (/create<\w+>\(\(set/.test(content)) {
      patterns[3].occurrences++;
    }

    // Signals
    const signalMatches = content.match(/@signal\(/g);
    if (signalMatches) {
      patterns[4].occurrences += signalMatches.length;
    }

    // Lifecycle
    const lifecycleMatches = content.match(/@lifecycle\(/g);
    if (lifecycleMatches) {
      patterns[5].occurrences += lifecycleMatches.length;
    }
  }

  return patterns.filter(p => p.occurrences > 0);
}

export async function getPatternSummary(basePath: string = DEFAULT_BASE_PATH): Promise<PatternSummary> {
  const [naming, decorators, organization, codePatterns] = await Promise.all([
    extractNamingConventions(basePath),
    extractDecoratorPatterns(basePath),
    extractFileOrganization(basePath),
    extractCodePatterns(basePath)
  ]);

  return {
    naming,
    decorators,
    organization,
    codePatterns
  };
}
