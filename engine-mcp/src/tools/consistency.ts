// src/tools/consistency.ts
// Consistency checker for the ASCII Dungeon engine MCP server
// Generated by Gemini 3 Flash

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export interface ConsistencyIssue {
  file: string;
  line?: number;
  severity: 'error' | 'warning' | 'info';
  rule: string;
  message: string;
  suggestion?: string;
}

export interface ConsistencyReport {
  issues: ConsistencyIssue[];
  summary: {
    errors: number;
    warnings: number;
    info: number;
  };
  passed: boolean;
}

export const DEFAULT_BASE_PATH = path.resolve(__dirname, '../../../editor/src');

/**
 * Helper to recursively walk a directory
 */
async function walk(dir: string): Promise<string[]> {
  const files = await fs.promises.readdir(dir, { withFileTypes: true });
  const paths = await Promise.all(
    files.map(async (file) => {
      if (file.name === 'node_modules' || file.name === 'dist' || file.name === '.git') {
        return [];
      }
      const res = path.resolve(dir, file.name);
      return file.isDirectory() ? walk(res) : res;
    })
  );
  return paths.flat();
}

/**
 * Check if a file is a TypeScript file and not a test/index file
 */
function isSourceFile(filePath: string): boolean {
  return (filePath.endsWith('.ts') || filePath.endsWith('.tsx')) &&
         !filePath.endsWith('.test.ts') &&
         !filePath.endsWith('.test.tsx') &&
         !path.basename(filePath).startsWith('index.');
}

export async function checkComponentConsistency(basePath: string = DEFAULT_BASE_PATH): Promise<ConsistencyIssue[]> {
  const issues: ConsistencyIssue[] = [];
  const componentsDir = path.join(basePath, 'scripting/components');

  if (!fs.existsSync(componentsDir)) return issues;

  const files = await walk(componentsDir);

  for (const file of files) {
    if (!isSourceFile(file)) continue;

    const fileName = path.basename(file);
    const relativePath = path.relative(basePath, file);

    // Rule 1: Component files should end with Component.ts
    if (!fileName.endsWith('Component.ts')) {
      issues.push({
        file: relativePath,
        severity: 'warning',
        rule: 'component-filename-suffix',
        message: 'Component files should end with "Component.ts"',
        suggestion: `Rename ${fileName} to ${fileName.replace('.ts', 'Component.ts')}`
      });
    }

    const content = await fs.promises.readFile(file, 'utf-8');

    // Rule 2: Components should have @component decorator
    if (!content.includes('@component(')) {
      issues.push({
        file: relativePath,
        severity: 'error',
        rule: 'missing-component-decorator',
        message: 'Classes in scripting/components must have the @component decorator'
      });
    }
  }

  return issues;
}

export async function checkNamingConsistency(basePath: string = DEFAULT_BASE_PATH): Promise<ConsistencyIssue[]> {
  const issues: ConsistencyIssue[] = [];
  const files = await walk(basePath);

  for (const file of files) {
    if (!isSourceFile(file)) continue;

    const content = await fs.promises.readFile(file, 'utf-8');
    const relativePath = path.relative(basePath, file);
    const lines = content.split('\n');

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Rule 5: Classes should be PascalCase
      const classMatch = line.match(/class\s+(\w+)/);
      if (classMatch) {
        const className = classMatch[1];
        if (!/^[A-Z][a-zA-Z0-9]+$/.test(className)) {
          issues.push({
            file: relativePath,
            line: i + 1,
            severity: 'warning',
            rule: 'naming-class-pascal',
            message: `Class name "${className}" should be PascalCase`,
            suggestion: `Rename to ${className.charAt(0).toUpperCase()}${className.slice(1)}`
          });
        }
      }

      // Rule 6: Functions should be camelCase
      const funcMatch = line.match(/(?:function|const|let)\s+([a-z]\w*)\s*=\s*(?:\([^)]*\)|function)/) ||
                        line.match(/function\s+([a-zA-Z]\w*)\s*\(/);
      if (funcMatch) {
        const funcName = funcMatch[1];
        // Skip if it looks like a React component (PascalCase) in a .tsx file
        const isReactComponent = file.endsWith('.tsx') && /^[A-Z]/.test(funcName);

        if (!isReactComponent && !/^[a-z][a-zA-Z0-9]*$/.test(funcName)) {
          // Basic check, avoid common false positives like Uppercase exports that are actually constants
          if (/^[A-Z_]+$/.test(funcName)) continue;

          issues.push({
            file: relativePath,
            line: i + 1,
            severity: 'info',
            rule: 'naming-function-camel',
            message: `Function name "${funcName}" should be camelCase`,
          });
        }
      }
    }
  }

  return issues;
}

export async function checkImportConsistency(basePath: string = DEFAULT_BASE_PATH): Promise<ConsistencyIssue[]> {
  const issues: ConsistencyIssue[] = [];
  const allFiles = await walk(basePath);
  const sourceFiles = allFiles.filter(isSourceFile);

  // For Rule 7: All exports should be used somewhere
  const exportMap = new Map<string, { file: string; line: number; count: number }>();

  for (const file of sourceFiles) {
    const content = await fs.promises.readFile(file, 'utf-8');
    const relativePath = path.relative(basePath, file);
    const lines = content.split('\n');

    let lastImportType: 'external' | 'internal' | null = null;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Rule 8: Imports should be organized (external first, then internal)
      if (line.startsWith('import ')) {
        const sourceMatch = line.match(/from\s+['"]([^'"]+)['"]/);
        if (sourceMatch) {
          const source = sourceMatch[1];
          const isInternal = source.startsWith('.') || source.startsWith('@/');
          const currentType = isInternal ? 'internal' : 'external';

          if (lastImportType === 'internal' && currentType === 'external') {
            issues.push({
              file: relativePath,
              line: i + 1,
              severity: 'info',
              rule: 'import-organization',
              message: 'External imports should come before internal imports',
              suggestion: 'Move this import above internal imports'
            });
          }
          lastImportType = currentType;
        }
      } else if (line.length > 0 && !line.startsWith('//') && !line.startsWith('/*')) {
        lastImportType = null; // Reset when we leave the import section
      }

      // Collect exports for Rule 7
      const exportMatch = line.match(/^export\s+(?:class|function|const|enum|type|interface)\s+([a-zA-Z]\w*)/);
      if (exportMatch) {
        const name = exportMatch[1];
        exportMap.set(name, { file: relativePath, line: i + 1, count: 0 });
      }
    }

    // Check usage of other exports in this file (simple string search)
    for (const [name, data] of exportMap.entries()) {
      if (data.file !== relativePath && content.includes(name)) {
        data.count++;
      }
    }
  }

  // Rule 7 report - only report truly unused exports (skip common things like types)
  for (const [name, data] of exportMap.entries()) {
    if (data.count === 0 && !name.endsWith('Props') && !name.endsWith('State')) {
      issues.push({
        file: data.file,
        line: data.line,
        severity: 'info',
        rule: 'unused-export',
        message: `Export "${name}" seems to be unused in the project`,
      });
    }
  }

  return issues;
}

export async function checkDecoratorConsistency(basePath: string = DEFAULT_BASE_PATH): Promise<ConsistencyIssue[]> {
  const issues: ConsistencyIssue[] = [];
  const files = await walk(basePath);

  for (const file of files) {
    if (!isSourceFile(file)) continue;

    const content = await fs.promises.readFile(file, 'utf-8');
    const relativePath = path.relative(basePath, file);
    const lines = content.split('\n');

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Rule 3: Properties should have @property decorator with type
      const propertyMatch = line.match(/@property\s*\(\s*\{([^}]*)\}\s*\)/);
      if (propertyMatch) {
        const opts = propertyMatch[1];
        if (!opts.includes('type:')) {
          issues.push({
            file: relativePath,
            line: i + 1,
            severity: 'error',
            rule: 'property-decorator-missing-type',
            message: '@property decorator is missing the "type" field',
            suggestion: 'Add type: "string" | "number" | "boolean" etc.'
          });
        }
      }

      // Rule 4: Actions should have @action decorator
      // Check if methods in components that look like actions are missing it
      if (relativePath.includes('scripting/components') && line.includes('():') && !line.includes('private')) {
        const prevLine = i > 0 ? lines[i - 1] : '';
        const prevPrevLine = i > 1 ? lines[i - 2] : '';
        if (!prevLine.includes('@action') && !prevPrevLine.includes('@action') &&
            !line.includes('constructor') && !line.includes('onInit') &&
            !line.includes('onUpdate') && !line.includes('onDispose') &&
            !line.includes('private') && !line.includes('protected')) {
          issues.push({
            file: relativePath,
            line: i + 1,
            severity: 'warning',
            rule: 'missing-action-decorator',
            message: 'Public component method might be missing @action decorator'
          });
        }
      }
    }
  }

  return issues;
}

export async function runAllChecks(basePath: string = DEFAULT_BASE_PATH): Promise<ConsistencyReport> {
  const allIssues = (await Promise.all([
    checkComponentConsistency(basePath),
    checkNamingConsistency(basePath),
    checkImportConsistency(basePath),
    checkDecoratorConsistency(basePath)
  ])).flat();

  const summary = {
    errors: allIssues.filter(i => i.severity === 'error').length,
    warnings: allIssues.filter(i => i.severity === 'warning').length,
    info: allIssues.filter(i => i.severity === 'info').length
  };

  return {
    issues: allIssues,
    summary,
    passed: summary.errors === 0
  };
}

/**
 * Get a formatted report string
 */
export function formatReport(report: ConsistencyReport): string {
  const lines: string[] = [];

  lines.push('='.repeat(60));
  lines.push('Consistency Check Report');
  lines.push('='.repeat(60));
  lines.push('');

  if (report.issues.length === 0) {
    lines.push('No issues found.');
  } else {
    // Group by file
    const byFile = new Map<string, ConsistencyIssue[]>();
    for (const issue of report.issues) {
      const existing = byFile.get(issue.file) || [];
      existing.push(issue);
      byFile.set(issue.file, existing);
    }

    for (const [file, issues] of byFile) {
      lines.push(`${file}:`);
      for (const issue of issues) {
        const loc = issue.line ? `:${issue.line}` : '';
        const sev = issue.severity.toUpperCase().padEnd(7);
        lines.push(`  ${loc.padEnd(5)} [${sev}] ${issue.message}`);
        if (issue.suggestion) {
          lines.push(`         â†’ ${issue.suggestion}`);
        }
      }
      lines.push('');
    }
  }

  lines.push('-'.repeat(60));
  lines.push(`Summary: ${report.summary.errors} errors, ${report.summary.warnings} warnings, ${report.summary.info} info`);
  lines.push(`Status: ${report.passed ? 'PASSED' : 'FAILED'}`);

  return lines.join('\n');
}
