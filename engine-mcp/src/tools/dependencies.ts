// src/tools/dependencies.ts
// Dependency graph analyzer for the ASCII Dungeon engine MCP server
// Generated by Gemini 3 Flash

import * as fs from 'fs';
import * as path from 'path';
import * as ts from 'typescript';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export interface DependencyNode {
  filePath: string;
  imports: string[];
  importedBy: string[];
}

export interface DependencyGraph {
  nodes: Map<string, DependencyNode>;
  edges: Map<string, Set<string>>;
}

export interface DependencyTreeNode {
  file: string;
  dependencies: DependencyTreeNode[];
}

export const DEFAULT_BASE_PATH = path.resolve(__dirname, '../../../editor/src');

async function getAllFiles(dirPath: string, arrayOfFiles: string[] = []): Promise<string[]> {
  const files = fs.readdirSync(dirPath);

  for (const file of files) {
    if (file === 'node_modules' || file === 'dist' || file === '.git') continue;

    const filePath = path.join(dirPath, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      await getAllFiles(filePath, arrayOfFiles);
    } else if (filePath.endsWith('.ts') || filePath.endsWith('.tsx')) {
      arrayOfFiles.push(filePath);
    }
  }

  return arrayOfFiles;
}

function resolveImportPath(sourceFile: string, importPath: string): string | null {
  if (!importPath.startsWith('.')) return null;

  const directory = path.dirname(sourceFile);
  const resolvedPath = path.resolve(directory, importPath);

  const extensions = ['.ts', '.tsx', '.d.ts', '.js', '.jsx'];

  if (fs.existsSync(resolvedPath) && fs.statSync(resolvedPath).isFile()) {
    return resolvedPath;
  }

  for (const ext of extensions) {
    const fullPath = resolvedPath + ext;
    if (fs.existsSync(fullPath)) {
      return fullPath;
    }
  }

  const indexFiles = ['/index.ts', '/index.tsx', '/index.d.ts', '/index.js', '/index.jsx'];
  for (const indexFile of indexFiles) {
    const fullPath = resolvedPath + indexFile;
    if (fs.existsSync(fullPath)) {
      return fullPath;
    }
  }

  return null;
}

function getImports(filePath: string): string[] {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const sourceFile = ts.createSourceFile(filePath, content, ts.ScriptTarget.Latest, true);
    const imports: string[] = [];

    function visit(node: ts.Node) {
      if (ts.isImportDeclaration(node)) {
        if (node.moduleSpecifier && ts.isStringLiteral(node.moduleSpecifier)) {
          const resolved = resolveImportPath(filePath, node.moduleSpecifier.text);
          if (resolved) imports.push(resolved);
        }
      } else if (ts.isExportDeclaration(node)) {
        if (node.moduleSpecifier && ts.isStringLiteral(node.moduleSpecifier)) {
          const resolved = resolveImportPath(filePath, node.moduleSpecifier.text);
          if (resolved) imports.push(resolved);
        }
      } else if (ts.isCallExpression(node)) {
        if (node.expression.kind === ts.SyntaxKind.ImportKeyword && node.arguments.length > 0) {
          const arg = node.arguments[0];
          if (ts.isStringLiteral(arg)) {
            const resolved = resolveImportPath(filePath, arg.text);
            if (resolved) imports.push(resolved);
          }
        }
      }
      ts.forEachChild(node, visit);
    }

    visit(sourceFile);
    return Array.from(new Set(imports));
  } catch (e) {
    return [];
  }
}

export async function buildDependencyGraph(basePath: string = DEFAULT_BASE_PATH): Promise<DependencyGraph> {
  const files = await getAllFiles(basePath);
  const graph: DependencyGraph = {
    nodes: new Map(),
    edges: new Map()
  };

  for (const file of files) {
    graph.nodes.set(file, {
      filePath: file,
      imports: [],
      importedBy: []
    });
    graph.edges.set(file, new Set());
  }

  for (const file of files) {
    const node = graph.nodes.get(file)!;
    const imports = getImports(file);

    for (const imp of imports) {
      if (graph.nodes.has(imp)) {
        node.imports.push(imp);
        graph.edges.get(file)!.add(imp);
        graph.nodes.get(imp)!.importedBy.push(file);
      }
    }
  }

  return graph;
}

export function getFileDependencies(filePath: string, graph: DependencyGraph): string[] {
  return graph.nodes.get(filePath)?.imports || [];
}

export function getFileDependents(filePath: string, graph: DependencyGraph): string[] {
  return graph.nodes.get(filePath)?.importedBy || [];
}

export function findCircularDependencies(graph: DependencyGraph): string[][] {
  const circulars: string[][] = [];
  const visited = new Set<string>();
  const recStack = new Set<string>();

  function detectCycle(node: string, currentPath: string[]) {
    visited.add(node);
    recStack.add(node);
    currentPath.push(node);

    const neighbors = graph.edges.get(node);
    if (neighbors) {
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
          detectCycle(neighbor, [...currentPath]);
        } else if (recStack.has(neighbor)) {
          const cycleStart = currentPath.indexOf(neighbor);
          circulars.push(currentPath.slice(cycleStart));
        }
      }
    }

    recStack.delete(node);
  }

  for (const node of graph.nodes.keys()) {
    if (!visited.has(node)) {
      detectCycle(node, []);
    }
  }

  return circulars;
}

export function findEntryPoints(graph: DependencyGraph): string[] {
  const entries: string[] = [];
  for (const [filePath, node] of graph.nodes) {
    if (node.importedBy.length === 0) {
      entries.push(filePath);
    }
  }
  return entries;
}

export function findCoreModules(graph: DependencyGraph, threshold: number = 5): string[] {
  return Array.from(graph.nodes.values())
    .filter(node => node.importedBy.length >= threshold)
    .sort((a, b) => b.importedBy.length - a.importedBy.length)
    .map(node => node.filePath);
}

export function getDependencyTree(
  filePath: string,
  graph: DependencyGraph,
  maxDepth: number = 10,
  currentDepth: number = 0,
  visited: Set<string> = new Set()
): DependencyTreeNode {
  const treeNode: DependencyTreeNode = {
    file: filePath,
    dependencies: []
  };

  if (currentDepth >= maxDepth || visited.has(filePath)) {
    return treeNode;
  }

  visited.add(filePath);
  const deps = getFileDependencies(filePath, graph);

  for (const dep of deps) {
    treeNode.dependencies.push(getDependencyTree(dep, graph, maxDepth, currentDepth + 1, new Set(visited)));
  }

  return treeNode;
}

/**
 * Get a summary of the dependency graph
 */
export function getDependencyStats(graph: DependencyGraph): {
  totalFiles: number;
  totalEdges: number;
  avgImports: number;
  avgImportedBy: number;
  circularCount: number;
  entryPoints: number;
  coreModules: number;
} {
  let totalEdges = 0;
  let totalImports = 0;
  let totalImportedBy = 0;

  for (const node of graph.nodes.values()) {
    totalImports += node.imports.length;
    totalImportedBy += node.importedBy.length;
    totalEdges += node.imports.length;
  }

  const totalFiles = graph.nodes.size;
  const circulars = findCircularDependencies(graph);
  const entries = findEntryPoints(graph);
  const core = findCoreModules(graph);

  return {
    totalFiles,
    totalEdges,
    avgImports: totalFiles > 0 ? totalImports / totalFiles : 0,
    avgImportedBy: totalFiles > 0 ? totalImportedBy / totalFiles : 0,
    circularCount: circulars.length,
    entryPoints: entries.length,
    coreModules: core.length
  };
}
